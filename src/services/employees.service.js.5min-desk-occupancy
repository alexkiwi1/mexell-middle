const { query } = require('../config/postgres');
const { unixToISO, unixToReadable, parseDateTimeRange } = require('./frigate.service');
const { 
  isValidTimezone, 
  getTimezoneName, 
  convertToISO, 
  convertToReadable, 
  getTimezoneInfo,
  processEmployeeTimezone,
  processBreakSessionsTimezone
} = require('./timezone.service');
const logger = require('../config/logger');

/**
 * Employee Service - Comprehensive employee tracking and attendance management
 * 
 * Features:
 * - Work hours calculation
 * - Break time tracking
 * - Attendance monitoring
 * - Desk occupancy analysis
 * - Employee activity patterns
 * - Productivity metrics
 */

/**
 * Get employee work hours for a specific date range
 * @param {Object} filters - Query filters
 * @returns {Object} Employee work hours data
 */
const getEmployeeWorkHours = async (filters = {}) => {
  try {
    const { start_date, end_date, hours, employee_name, camera, timezone = 'UTC' } = filters;
    const { startTime, endTime } = parseDateTimeRange({ start_date, end_date, hours, timezone });
    
    // Validate timezone
    if (!isValidTimezone(timezone)) {
      throw new Error(`Invalid timezone: ${timezone}`);
    }

    let whereClause = `
      WHERE timestamp >= $1 AND timestamp <= $2
      AND data->>'label' = 'person'
      AND data->'sub_label'->>0 IS NOT NULL
    `;
    const params = [startTime, endTime];
    let paramIndex = 3;

    if (employee_name) {
      whereClause += ` AND data->'sub_label'->>0 = $${paramIndex}`;
      params.push(employee_name);
      paramIndex++;
    }

    if (camera) {
      whereClause += ` AND camera = $${paramIndex}`;
      params.push(camera);
      paramIndex++;
    }

    // Get all person detections for proper work hours calculation
    const sql = `
      SELECT
        data->'sub_label'->>0 as employee_name,
        camera,
        data->'zones' as zones,
        timestamp,
        data->>'score' as confidence
      FROM timeline
      ${whereClause}
      ORDER BY data->'sub_label'->>0, timestamp
    `;

    const result = await query(sql, params);
    logger.info(`Found ${result.length} person detections for work hours calculation`);

    // Process detections and calculate work hours properly
    const employeeData = {};
    
    // Group detections by employee
    result.forEach(row => {
      const employee = row.employee_name || 'Unknown';
      if (!employeeData[employee]) {
        employeeData[employee] = {
          employee_name: employee,
          total_work_hours: 0,
          total_activity: 0,
          cameras: new Set(),
          zones: new Set(),
          sessions: [],
          first_seen: null,
          last_seen: null,
          detections: [] // Store all detections for proper calculation
        };
      }

      employeeData[employee].total_activity++;
      employeeData[employee].cameras.add(row.camera);
      
      if (row.zones) {
        row.zones.forEach(zone => employeeData[employee].zones.add(zone));
      }

      // Store detection data
      employeeData[employee].detections.push({
        timestamp: row.timestamp,
        camera: row.camera,
        zones: row.zones || [],
        confidence: parseFloat(row.confidence) || 0
      });

      if (!employeeData[employee].first_seen || row.timestamp < employeeData[employee].first_seen) {
        employeeData[employee].first_seen = unixToISO(row.timestamp);
      }
      if (!employeeData[employee].last_seen || row.timestamp > employeeData[employee].last_seen) {
        employeeData[employee].last_seen = unixToISO(row.timestamp);
      }
    });

    // Calculate work hours by finding continuous presence periods
    Object.values(employeeData).forEach(employee => {
      const detections = employee.detections;
      if (detections.length === 0) return;

      // Sort detections by timestamp
      detections.sort((a, b) => a.timestamp - b.timestamp);

      // Group detections into continuous work sessions
      const workSessions = [];
      let currentSession = null;
      const MAX_GAP_MINUTES = 10; // 10 minutes gap = new session
      const MAX_GAP_SECONDS = MAX_GAP_MINUTES * 60;

      detections.forEach((detection, index) => {
        if (!currentSession) {
          // Start new session
          currentSession = {
            start_time: detection.timestamp,
            end_time: detection.timestamp,
            cameras: new Set([detection.camera]),
            zones: new Set(detection.zones || []),
            detection_count: 1,
            avg_confidence: detection.confidence
          };
        } else {
          const gap = detection.timestamp - currentSession.end_time;
          
          if (gap <= MAX_GAP_SECONDS) {
            // Continue current session
            currentSession.end_time = detection.timestamp;
            currentSession.cameras.add(detection.camera);
            if (detection.zones) {
              detection.zones.forEach(zone => currentSession.zones.add(zone));
            }
            currentSession.detection_count++;
            currentSession.avg_confidence = (currentSession.avg_confidence + detection.confidence) / 2;
          } else {
            // Gap too large - save current session and start new one
            workSessions.push({
              ...currentSession,
              cameras: Array.from(currentSession.cameras),
              zones: Array.from(currentSession.zones),
              duration_hours: (currentSession.end_time - currentSession.start_time) / 3600,
              first_seen: unixToISO(currentSession.start_time),
              last_seen: unixToISO(currentSession.end_time)
            });
            
            // Start new session
            currentSession = {
              start_time: detection.timestamp,
              end_time: detection.timestamp,
              cameras: new Set([detection.camera]),
              zones: new Set(detection.zones || []),
              detection_count: 1,
              avg_confidence: detection.confidence
            };
          }
        }
      });

      // Don't forget the last session
      if (currentSession) {
        workSessions.push({
          ...currentSession,
          cameras: Array.from(currentSession.cameras),
          zones: Array.from(currentSession.zones),
          duration_hours: (currentSession.end_time - currentSession.start_time) / 3600,
          first_seen: unixToISO(currentSession.start_time),
          last_seen: unixToISO(currentSession.end_time)
        });
      }

      // Calculate arrival and departure times (store as Unix timestamps for timezone conversion)
      // Find first session with 5+ minutes of desk occupancy for arrival
      const MIN_ARRIVAL_MINUTES = 5;
      const arrivalSession = findArrivalSession(workSessions, employee.detections, MIN_ARRIVAL_MINUTES);
      employee.arrival_timestamp = arrivalSession ? arrivalSession.start_time : null;
      employee.departure_timestamp = workSessions.length > 0 ? workSessions[workSessions.length - 1].end_time : null;
      
      // Calculate total time at office (arrival to departure)
      // If no qualifying arrival found, use first detection as fallback for time calculation
      const effectiveArrivalTime = employee.arrival_timestamp || (workSessions.length > 0 ? workSessions[0].start_time : null);
      employee.total_time = effectiveArrivalTime && employee.departure_timestamp 
        ? (employee.departure_timestamp - effectiveArrivalTime) / 3600 
        : 0;

      // Calculate break time using presence/absence logic with desk occupancy
      const breakCalculation = calculateBreaksFromDetections(
        employee.detections, 
        effectiveArrivalTime, 
        employee.departure_timestamp,
        30, // 30-minute break threshold
        employee.employee_name
      );
      employee.total_break_time = breakCalculation.totalBreakTime;

      // Calculate office time (total time - break time)
      employee.total_work_hours = employee.total_time - employee.total_break_time;
      employee.office_time = employee.total_work_hours; // Alias for clarity

      // Validate time consistency
      validateTimeConsistency(employee);
      
      // Convert to timezone-specific times
      employee.arrival_time = employee.arrival_timestamp ? convertToISO(employee.arrival_timestamp, timezone) : null;
      employee.departure_time = employee.departure_timestamp ? convertToISO(employee.departure_timestamp, timezone) : null;
      
      // Also store first_seen and last_seen for compatibility
      employee.first_seen = employee.arrival_time;
      employee.last_seen = employee.departure_time;

      logger.info(`Employee ${employee.employee_name}: ${workSessions.length} sessions, Total=${employee.total_time.toFixed(2)}h, Office=${employee.office_time.toFixed(2)}h, Break=${employee.total_break_time.toFixed(2)}h`);
      
      // Log arrival qualification status
      if (arrivalSession) {
        logger.info(`Employee ${employee.employee_name}: Arrival qualified at ${convertToISO(arrivalSession.start_time, timezone)} (${arrivalSession.arrival_reason})`);
      } else {
        logger.warn(`Employee ${employee.employee_name}: No qualifying arrival found (no 5+ minute desk occupancy)`);
      }

      // Store work sessions with timezone conversion
      employee.sessions = workSessions.map(session => ({
        ...session,
        first_seen: convertToISO(session.start_time, timezone),
        last_seen: convertToISO(session.end_time, timezone)
      }));

      // Store detections for break calculation (don't delete)
      // employee.detections will be used by break-time endpoint
    });

    // Convert sets to arrays and add calculated fields
    const employees = Object.values(employeeData).map(emp => ({
      ...emp,
      cameras: Array.from(emp.cameras),
      zones: Array.from(emp.zones),
      average_session_duration: emp.sessions.length > 0 
        ? emp.total_work_hours / emp.sessions.length 
        : 0,
      productivity_score: calculateProductivityScore(emp),
      attendance_status: getAttendanceStatus(emp.total_work_hours),
      work_efficiency: calculateWorkEfficiency(emp),
      // Add new time fields for consistency
      total_time: emp.total_time || 0,
      total_break_time: emp.total_break_time || 0,
      office_time: emp.office_time || 0,
      unaccounted_time: 0 // Should always be 0 with correct calculation
    }));

    return {
      employees,
      total_employees: employees.length,
      total_work_hours: employees.reduce((sum, emp) => sum + emp.total_work_hours, 0),
      average_work_hours: employees.length > 0 
        ? employees.reduce((sum, emp) => sum + emp.total_work_hours, 0) / employees.length 
        : 0,
      period: {
        start: convertToISO(startTime, timezone),
        end: convertToISO(endTime, timezone),
        duration_hours: (endTime - startTime) / 3600
      },
      timezone_info: getTimezoneInfo(timezone)
    };

  } catch (error) {
    logger.error('Error in getEmployeeWorkHours:', error);
    throw error;
  }
};

/**
 * Get employee break time analysis
 * @param {Object} filters - Query filters
 * @returns {Object} Break time data
 */
const getEmployeeBreakTime = async (filters = {}) => {
  try {
    const { start_date, end_date, hours, employee_name, camera, timezone = 'UTC' } = filters;
    const { startTime, endTime } = parseDateTimeRange({ start_date, end_date, hours, timezone });
    
    // Validate timezone
    if (!isValidTimezone(timezone)) {
      throw new Error(`Invalid timezone: ${timezone}`);
    }

    // Get work hours data first to use the session-based approach
    const workHoursData = await getEmployeeWorkHours(filters);
    
    if (!workHoursData || !workHoursData.employees || workHoursData.employees.length === 0) {
      return {
        employees: [],
        total_employees: 0,
        total_break_time: 0,
        average_break_time: 0
      };
    }

    const breakData = [];

    // Process each employee to find breaks
    for (const employee of workHoursData.employees) {
      // Use presence/absence break calculation logic with desk occupancy
      const breakCalculation = calculateBreaksFromDetections(
        employee.detections || [],
        employee.arrival_timestamp,
        employee.departure_timestamp,
        30, // 30-minute break threshold
        employee.employee_name
      );

      if (breakCalculation.breakSessions.length > 0) {
        const totalBreakTime = breakCalculation.totalBreakTime;
        const breakSessions = breakCalculation.breakSessions;
        
        const averageBreakDuration = totalBreakTime / breakSessions.length;
        const longestBreak = Math.max(...breakSessions.map(bs => bs.duration_hours));
        const shortestBreak = Math.min(...breakSessions.map(bs => bs.duration_hours));
        const breakFrequency = breakSessions.length / Math.max(employee.total_time, 1); // Use total time at office
        const breakEfficiency = Math.max(0, 100 - (breakFrequency * 10)); // Simple efficiency calculation

        breakData.push({
          employee_name: employee.employee_name,
          total_breaks: breakSessions.length,
          total_break_time: totalBreakTime,
          break_sessions: processBreakSessionsTimezone(breakSessions, timezone),
          average_break_duration: averageBreakDuration,
          longest_break: longestBreak,
          shortest_break: shortestBreak,
          break_frequency: breakFrequency,
          break_efficiency: breakEfficiency,
          // Include work hours context for consistency
          work_hours: employee.total_work_hours,
          office_time: employee.office_time,
          total_time: employee.total_time,
          arrival_time: employee.arrival_time,
          departure_time: employee.departure_time
        });
      }
    }

    // Calculate overall statistics
    const totalBreakTime = breakData.reduce((sum, emp) => sum + emp.total_break_time, 0);
    const averageBreakTime = breakData.length > 0 ? totalBreakTime / breakData.length : 0;

    return {
      employees: breakData,
      total_employees: breakData.length,
      total_break_time: totalBreakTime,
      average_break_time: averageBreakTime,
      timezone_info: getTimezoneInfo(timezone)
    };

  } catch (error) {
    logger.error('Error in getEmployeeBreakTime:', error);
    throw error;
  }
};

/**
 * Get employee attendance summary
 * @param {Object} filters - Query filters
 * @returns {Object} Attendance data
 */
const getEmployeeAttendance = async (filters = {}) => {
  try {
    const { start_date, end_date, hours, employee_name, timezone = 'UTC' } = filters;
    const { startTime, endTime } = parseDateTimeRange({ start_date, end_date, hours, timezone });

    let whereClause = `
      WHERE timestamp >= $1 AND timestamp <= $2
      AND class_type = 'entered_zone'
      AND data->>'label' = 'person'
    `;
    const params = [startTime, endTime];
    let paramIndex = 3;

    if (employee_name) {
      whereClause += ` AND data->'sub_label'->>0 = $${paramIndex}`;
      params.push(employee_name);
      paramIndex++;
    }

    const sql = `
      SELECT
        data->'sub_label'->>0 as employee_name,
        DATE(to_timestamp(timestamp)) as attendance_date,
        MIN(timestamp) as first_seen,
        MAX(timestamp) as last_seen,
        COUNT(*) as activity_count,
        (MAX(timestamp) - MIN(timestamp)) / 3600 as work_hours
      FROM timeline
      ${whereClause}
      GROUP BY data->'sub_label'->>0, DATE(to_timestamp(timestamp))
      ORDER BY attendance_date DESC, data->'sub_label'->>0
    `;

    const result = await query(sql, params);

    // Process attendance data
    const attendanceData = {};
    
    result.forEach(row => {
      const employee = row.employee_name || 'Unknown';
      if (!attendanceData[employee]) {
        attendanceData[employee] = {
          employee_name: employee,
          total_days: 0,
          total_work_hours: 0,
          attendance_records: [],
          attendance_rate: 0,
          average_daily_hours: 0,
          perfect_attendance: true
        };
      }

      const workHours = parseFloat(row.work_hours) || 0;
      attendanceData[employee].total_days++;
      attendanceData[employee].total_work_hours += workHours;
      attendanceData[employee].attendance_records.push({
        date: row.attendance_date,
        first_seen: unixToISO(row.first_seen),
        last_seen: unixToISO(row.last_seen),
        work_hours: workHours,
        activity_count: parseInt(row.activity_count) || 0,
        status: getDailyAttendanceStatus(workHours)
      });

      // Check for perfect attendance (assuming 8+ hours is full day)
      if (workHours < 8) {
        attendanceData[employee].perfect_attendance = false;
      }
    });

    // Calculate summary statistics
    const employees = Object.values(attendanceData).map(emp => {
      const totalDaysInPeriod = Math.ceil((endTime - startTime) / (24 * 3600));
      return {
        ...emp,
        attendance_rate: totalDaysInPeriod > 0 ? (emp.total_days / totalDaysInPeriod) * 100 : 0,
        average_daily_hours: emp.total_days > 0 ? emp.total_work_hours / emp.total_days : 0,
        attendance_score: calculateAttendanceScore(emp),
        consistency_rating: calculateConsistencyRating(emp.attendance_records)
      };
    });

    return {
      employees,
      total_employees: employees.length,
      period_days: Math.ceil((endTime - startTime) / (24 * 3600)),
      overall_attendance_rate: employees.length > 0 
        ? employees.reduce((sum, emp) => sum + emp.attendance_rate, 0) / employees.length 
        : 0
    };

  } catch (error) {
    logger.error('Error in getEmployeeAttendance:', error);
    throw error;
  }
};

/**
 * Get employee activity patterns
 * @param {Object} filters - Query filters
 * @returns {Object} Activity pattern data
 */
const getEmployeeActivityPatterns = async (filters = {}) => {
  try {
    const { start_date, end_date, hours, employee_name, camera, timezone = 'UTC' } = filters;
    const { startTime, endTime } = parseDateTimeRange({ start_date, end_date, hours, timezone });

    let whereClause = `
      WHERE timestamp >= $1 AND timestamp <= $2
      AND data->>'label' = 'person'
    `;
    const params = [startTime, endTime];
    let paramIndex = 3;

    if (employee_name) {
      whereClause += ` AND data->'sub_label'->>0 = $${paramIndex}`;
      params.push(employee_name);
      paramIndex++;
    }

    if (camera) {
      whereClause += ` AND camera = $${paramIndex}`;
      params.push(camera);
      paramIndex++;
    }

    const sql = `
      SELECT
        data->'sub_label'->>0 as employee_name,
        camera,
        data->'zones' as zones,
        EXTRACT(HOUR FROM to_timestamp(timestamp)) as hour_of_day,
        EXTRACT(DOW FROM to_timestamp(timestamp)) as day_of_week,
        COUNT(*) as activity_count
      FROM timeline
      ${whereClause}
      GROUP BY data->'sub_label'->>0, camera, data->'zones', 
               EXTRACT(HOUR FROM to_timestamp(timestamp)), 
               EXTRACT(DOW FROM to_timestamp(timestamp))
      ORDER BY data->'sub_label'->>0, hour_of_day, day_of_week
    `;

    const result = await query(sql, params);

    // Process activity patterns
    const patternData = {};
    
    result.forEach(row => {
      const employee = row.employee_name || 'Unknown';
      if (!patternData[employee]) {
        patternData[employee] = {
          employee_name: employee,
          hourly_patterns: {},
          daily_patterns: {},
          zone_preferences: {},
          camera_usage: {},
          peak_hours: [],
          most_active_day: null,
          activity_consistency: 0
        };
      }

      const hour = parseInt(row.hour_of_day);
      const day = parseInt(row.day_of_week);
      const activityCount = parseInt(row.activity_count) || 0;

      // Hourly patterns
      if (!patternData[employee].hourly_patterns[hour]) {
        patternData[employee].hourly_patterns[hour] = 0;
      }
      patternData[employee].hourly_patterns[hour] += activityCount;

      // Daily patterns
      if (!patternData[employee].daily_patterns[day]) {
        patternData[employee].daily_patterns[day] = 0;
      }
      patternData[employee].daily_patterns[day] += activityCount;

      // Zone preferences
      if (row.zones) {
        row.zones.forEach(zone => {
          if (!patternData[employee].zone_preferences[zone]) {
            patternData[employee].zone_preferences[zone] = 0;
          }
          patternData[employee].zone_preferences[zone] += activityCount;
        });
      }

      // Camera usage
      if (!patternData[employee].camera_usage[row.camera]) {
        patternData[employee].camera_usage[row.camera] = 0;
      }
      patternData[employee].camera_usage[row.camera] += activityCount;
    });

    // Calculate patterns and insights
    const employees = Object.values(patternData).map(emp => {
      const hourlyValues = Object.values(emp.hourly_patterns);
      const dailyValues = Object.values(emp.daily_patterns);
      
      return {
        ...emp,
        peak_hours: findPeakHours(emp.hourly_patterns),
        most_active_day: findMostActiveDay(emp.daily_patterns),
        activity_consistency: calculateActivityConsistency(hourlyValues),
        productivity_trends: analyzeProductivityTrends(emp.hourly_patterns),
        work_style: determineWorkStyle(emp.hourly_patterns),
        zone_diversity: Object.keys(emp.zone_preferences).length,
        camera_diversity: Object.keys(emp.camera_usage).length
      };
    });

    return {
      employees,
      total_employees: employees.length,
      insights: generateActivityInsights(employees)
    };

  } catch (error) {
    logger.error('Error in getEmployeeActivityPatterns:', error);
    throw error;
  }
};

// Helper functions

/**
 * Calculate breaks from employee detections using presence/absence logic
 * Includes desk occupancy as working time (if employee is at their designated desk)
 * @param {Array} detections - Array of all employee detections sorted by timestamp
 * @param {number} arrivalTimestamp - Employee arrival time (Unix timestamp)
 * @param {number} departureTimestamp - Employee departure time (Unix timestamp)
 * @param {number} MIN_BREAK_MINUTES - Minimum break duration in minutes
 * @param {string} employeeName - Employee name for desk assignment lookup
 * @returns {Object} Break calculation results
 */
const calculateBreaksFromDetections = (detections, arrivalTimestamp, departureTimestamp, MIN_BREAK_MINUTES = 30, employeeName = null) => {
  if (!detections || detections.length === 0) {
    return { totalBreakTime: 0, breakSessions: [] };
  }

  const MIN_BREAK_DURATION_SECONDS = MIN_BREAK_MINUTES * 60;
  const breakSessions = [];
  let totalBreakTime = 0;

  // Sort detections by timestamp
  const sortedDetections = detections.sort((a, b) => a.timestamp - b.timestamp);
  
  // Create a presence timeline with desk occupancy consideration
  const presenceTimeline = [];
  let currentPresence = null;

  // Helper function to check if detection indicates working (camera detection OR desk occupancy)
  const isWorkingDetection = (detection) => {
    // If employee is detected on camera, they're working
    if (detection.camera && detection.camera !== 'meeting_room') {
      return true;
    }
    
    // If employee is at their designated desk, they're working
    if (detection.zones && detection.zones.length > 0) {
      const hasDeskZone = detection.zones.some(zone => zone.startsWith('desk_'));
      if (hasDeskZone) {
        return true;
      }
    }
    
    return false;
  };

  // Helper function to check if employee's desk is occupied by someone else
  const isDeskOccupiedByOthers = (detection, employeeName) => {
    if (!detection.zones || !employeeName) return false;
    
    // Check if any desk zones are detected
    const deskZones = detection.zones.filter(zone => zone.startsWith('desk_'));
    if (deskZones.length === 0) return false;
    
    // For now, we'll assume if desk zones are detected, someone is there
    // In a more sophisticated system, we'd check if it's the same employee
    // This is a simplified check - desk zones present = desk occupied
    return true;
  };

  // Group consecutive detections into presence periods
  for (const detection of sortedDetections) {
    const isWorking = isWorkingDetection(detection);
    
    if (!currentPresence) {
      // Start new presence period
      currentPresence = {
        start: detection.timestamp,
        end: detection.timestamp,
        detections: [detection],
        isWorking: isWorking
      };
    } else {
      const gap = detection.timestamp - currentPresence.end;
      
      // If both detections are working (or both non-working), continue the period
      if (currentPresence.isWorking === isWorking && gap <= MIN_BREAK_DURATION_SECONDS) {
        // Continue current presence period
        currentPresence.end = detection.timestamp;
        currentPresence.detections.push(detection);
      } else {
        // Different work status or gap too large - save current presence and start new one
        presenceTimeline.push(currentPresence);
        currentPresence = {
          start: detection.timestamp,
          end: detection.timestamp,
          detections: [detection],
          isWorking: isWorking
        };
      }
    }
  }

  // Don't forget the last presence period
  if (currentPresence) {
    presenceTimeline.push(currentPresence);
  }

  // Calculate breaks between non-working periods
  // Only count as break if employee is not detected AND desk is empty for >30 minutes
  for (let i = 0; i < presenceTimeline.length - 1; i++) {
    const currentPresence = presenceTimeline[i];
    const nextPresence = presenceTimeline[i + 1];
    
    // Only count as break if:
    // 1. Current period was working (employee was detected)
    // 2. Next period is also working (employee detected again)
    // 3. Gap between them is â‰¥30 minutes
    // 4. During the gap, employee was not detected anywhere AND desk was empty
    if (currentPresence.isWorking && nextPresence.isWorking) {
      const breakStart = currentPresence.end;
      const breakEnd = nextPresence.start;
      const breakDuration = (breakEnd - breakStart) / 3600; // Convert to hours

      if (breakDuration >= MIN_BREAK_MINUTES / 60) {
        // Check if during the break period, employee was not detected anywhere
        // and their desk was empty (no desk zone detections)
        const breakPeriodDetections = sortedDetections.filter(detection => 
          detection.timestamp > breakStart && detection.timestamp < breakEnd
        );
        
        const wasEmployeeDetectedDuringBreak = breakPeriodDetections.some(detection => 
          isWorkingDetection(detection)
        );
        
        const wasDeskOccupiedDuringBreak = breakPeriodDetections.some(detection => 
          isDeskOccupiedByOthers(detection, employeeName)
        );
        
        // Only count as break if employee was NOT detected AND desk was empty
        if (!wasEmployeeDetectedDuringBreak && !wasDeskOccupiedDuringBreak) {
          breakSessions.push({
            break_start: new Date(breakStart * 1000).toISOString(),
            break_end: new Date(breakEnd * 1000).toISOString(),
            duration_hours: breakDuration,
            previous_presence: {
              ended_at: new Date(breakStart * 1000).toISOString(),
              detection_count: currentPresence.detections.length,
              was_working: currentPresence.isWorking
            },
            next_presence: {
              started_at: new Date(breakEnd * 1000).toISOString(),
              detection_count: nextPresence.detections.length,
              was_working: nextPresence.isWorking
            },
            break_conditions: {
              employee_not_detected: !wasEmployeeDetectedDuringBreak,
              desk_empty: !wasDeskOccupiedDuringBreak,
              gap_duration_minutes: breakDuration * 60
            }
          });
          
          totalBreakTime += breakDuration;
        }
      }
    }
  }

  return { totalBreakTime, breakSessions };
};

/**
 * Find the first work session that qualifies as "arrival"
 * Requires 5+ minutes of continuous desk zone occupancy
 * @param {Array} workSessions - All work sessions for the employee
 * @param {Array} detections - All detections for the employee
 * @param {number} minMinutes - Minimum minutes at desk (default 5)
 * @returns {Object|null} First qualifying session or null
 */
const findArrivalSession = (workSessions, detections, minMinutes = 5) => {
  const MIN_DURATION_SECONDS = minMinutes * 60;
  
  for (const session of workSessions) {
    // Check if this session has desk zone detections
    const sessionDetections = detections.filter(d => 
      d.timestamp >= session.start_time && 
      d.timestamp <= session.end_time
    );
    
    // Find continuous desk occupancy periods within this session
    const deskPeriods = findContinuousDeskOccupancy(sessionDetections, MIN_DURATION_SECONDS);
    
    // If any desk period is >= 5 minutes, this is the arrival session
    if (deskPeriods.length > 0) {
      // Return session with adjusted start_time to when desk occupancy began
      return {
        ...session,
        start_time: deskPeriods[0].start_time,
        arrival_reason: `Desk occupied for ${(deskPeriods[0].duration / 60).toFixed(1)} minutes`
      };
    }
  }
  
  return null; // No qualifying arrival found
};

/**
 * Find continuous desk occupancy periods
 * @param {Array} detections - Detections sorted by timestamp
 * @param {number} minDurationSeconds - Minimum duration in seconds
 * @returns {Array} Qualifying desk occupancy periods
 */
const findContinuousDeskOccupancy = (detections, minDurationSeconds) => {
  const deskPeriods = [];
  let currentPeriod = null;
  const MAX_GAP_SECONDS = 60; // Allow 60-second gaps between detections
  
  for (const detection of detections) {
    // Check if detection is in a desk zone
    const hasDeskZone = detection.zones && detection.zones.some(z => z.startsWith('desk_'));
    
    if (hasDeskZone) {
      if (!currentPeriod) {
        // Start new desk period
        currentPeriod = {
          start_time: detection.timestamp,
          end_time: detection.timestamp,
          detections: [detection]
        };
      } else {
        const gap = detection.timestamp - currentPeriod.end_time;
        
        if (gap <= MAX_GAP_SECONDS) {
          // Continue current period
          currentPeriod.end_time = detection.timestamp;
          currentPeriod.detections.push(detection);
        } else {
          // Gap too large - save current period if it qualifies
          const duration = currentPeriod.end_time - currentPeriod.start_time;
          if (duration >= minDurationSeconds) {
            deskPeriods.push({
              ...currentPeriod,
              duration: duration
            });
          }
          
          // Start new period
          currentPeriod = {
            start_time: detection.timestamp,
            end_time: detection.timestamp,
            detections: [detection]
          };
        }
      }
    } else {
      // Non-desk detection - end current period if exists
      if (currentPeriod) {
        const duration = currentPeriod.end_time - currentPeriod.start_time;
        if (duration >= minDurationSeconds) {
          deskPeriods.push({
            ...currentPeriod,
            duration: duration
          });
        }
        currentPeriod = null;
      }
    }
  }
  
  // Don't forget last period
  if (currentPeriod) {
    const duration = currentPeriod.end_time - currentPeriod.start_time;
    if (duration >= minDurationSeconds) {
      deskPeriods.push({
        ...currentPeriod,
        duration: duration
      });
    }
  }
  
  return deskPeriods;
};

/**
 * Validate time consistency for an employee
 * @param {Object} employee - Employee data object
 */
const validateTimeConsistency = (employee) => {
  const calculated = employee.office_time + employee.total_break_time;
  const difference = Math.abs(employee.total_time - calculated);
  if (difference > 0.01) { // Allow 36-second rounding tolerance
    logger.warn(`Time inconsistency for ${employee.employee_name}: 
      Total=${employee.total_time}h, 
      Office=${employee.office_time}h, 
      Break=${employee.total_break_time}h, 
      Diff=${difference}h`);
  }
};

/**
 * Calculate productivity score based on work hours and activity
 */
const calculateProductivityScore = (employee) => {
  const baseScore = Math.min(employee.total_work_hours / 8, 1) * 50; // 50 points for full day
  const activityScore = Math.min(employee.total_activity / 100, 1) * 30; // 30 points for activity
  const consistencyScore = employee.sessions.length > 0 ? 20 : 0; // 20 points for consistency
  
  return Math.round(baseScore + activityScore + consistencyScore);
};

/**
 * Get attendance status based on work hours
 */
const getAttendanceStatus = (workHours) => {
  if (workHours >= 8) return 'full_day';
  if (workHours >= 4) return 'half_day';
  if (workHours > 0) return 'partial_day';
  return 'absent';
};

/**
 * Calculate work efficiency
 */
const calculateWorkEfficiency = (employee) => {
  const expectedHours = 8; // Standard work day
  const actualHours = employee.total_work_hours;
  const efficiency = (actualHours / expectedHours) * 100;
  return Math.min(Math.round(efficiency), 100);
};

/**
 * Calculate break efficiency
 */
const calculateBreakEfficiency = (employee) => {
  const totalWorkTime = 8; // Assume 8 hour work day
  const breakTime = employee.total_break_time;
  const efficiency = ((totalWorkTime - breakTime) / totalWorkTime) * 100;
  return Math.max(Math.round(efficiency), 0);
};

/**
 * Get daily attendance status
 */
const getDailyAttendanceStatus = (workHours) => {
  if (workHours >= 8) return 'present';
  if (workHours >= 4) return 'partial';
  if (workHours > 0) return 'late';
  return 'absent';
};

/**
 * Calculate attendance score
 */
const calculateAttendanceScore = (employee) => {
  const baseScore = employee.attendance_rate;
  const consistencyBonus = employee.perfect_attendance ? 10 : 0;
  return Math.min(baseScore + consistencyBonus, 100);
};

/**
 * Calculate consistency rating
 */
const calculateConsistencyRating = (records) => {
  if (records.length < 2) return 100;
  
  const hours = records.map(r => r.work_hours);
  const mean = hours.reduce((a, b) => a + b, 0) / hours.length;
  const variance = hours.reduce((sum, h) => sum + Math.pow(h - mean, 2), 0) / hours.length;
  const stdDev = Math.sqrt(variance);
  
  const consistency = Math.max(0, 100 - (stdDev / mean) * 100);
  return Math.round(consistency);
};

/**
 * Find peak hours
 */
const findPeakHours = (hourlyPatterns) => {
  const sorted = Object.entries(hourlyPatterns)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 3);
  return sorted.map(([hour, count]) => ({ hour: parseInt(hour), activity: count }));
};

/**
 * Find most active day
 */
const findMostActiveDay = (dailyPatterns) => {
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const sorted = Object.entries(dailyPatterns)
    .sort(([,a], [,b]) => b - a);
  return sorted.length > 0 ? {
    day: days[parseInt(sorted[0][0])],
    activity: sorted[0][1]
  } : null;
};

/**
 * Calculate activity consistency
 */
const calculateActivityConsistency = (values) => {
  if (values.length < 2) return 100;
  
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
  const stdDev = Math.sqrt(variance);
  
  const consistency = Math.max(0, 100 - (stdDev / mean) * 100);
  return Math.round(consistency);
};

/**
 * Analyze productivity trends
 */
const analyzeProductivityTrends = (hourlyPatterns) => {
  const morning = [6, 7, 8, 9, 10, 11].reduce((sum, h) => sum + (hourlyPatterns[h] || 0), 0);
  const afternoon = [12, 13, 14, 15, 16, 17].reduce((sum, h) => sum + (hourlyPatterns[h] || 0), 0);
  const evening = [18, 19, 20, 21, 22, 23].reduce((sum, h) => sum + (hourlyPatterns[h] || 0), 0);
  
  const total = morning + afternoon + evening;
  if (total === 0) return 'unknown';
  
  if (morning > afternoon && morning > evening) return 'morning_person';
  if (afternoon > morning && afternoon > evening) return 'afternoon_person';
  if (evening > morning && evening > afternoon) return 'evening_person';
  return 'balanced';
};

/**
 * Determine work style
 */
const determineWorkStyle = (hourlyPatterns) => {
  const earlyHours = [6, 7, 8].reduce((sum, h) => sum + (hourlyPatterns[h] || 0), 0);
  const regularHours = [9, 10, 11, 12, 13, 14, 15, 16, 17].reduce((sum, h) => sum + (hourlyPatterns[h] || 0), 0);
  const lateHours = [18, 19, 20, 21, 22, 23].reduce((sum, h) => sum + (hourlyPatterns[h] || 0), 0);
  
  const total = earlyHours + regularHours + lateHours;
  if (total === 0) return 'unknown';
  
  if (earlyHours > regularHours && earlyHours > lateHours) return 'early_bird';
  if (lateHours > earlyHours && lateHours > regularHours) return 'night_owl';
  return 'regular_schedule';
};

/**
 * Generate activity insights
 */
const generateActivityInsights = (employees) => {
  const totalEmployees = employees.length;
  if (totalEmployees === 0) return {};

  const morningPeople = employees.filter(e => e.productivity_trends === 'morning_person').length;
  const eveningPeople = employees.filter(e => e.productivity_trends === 'evening_person').length;
  const earlyBirds = employees.filter(e => e.work_style === 'early_bird').length;
  const nightOwls = employees.filter(e => e.work_style === 'night_owl').length;

  return {
    total_employees: totalEmployees,
    productivity_distribution: {
      morning_person: Math.round((morningPeople / totalEmployees) * 100),
      evening_person: Math.round((eveningPeople / totalEmployees) * 100),
      balanced: Math.round(((totalEmployees - morningPeople - eveningPeople) / totalEmployees) * 100)
    },
    work_style_distribution: {
      early_bird: Math.round((earlyBirds / totalEmployees) * 100),
      night_owl: Math.round((nightOwls / totalEmployees) * 100),
      regular_schedule: Math.round(((totalEmployees - earlyBirds - nightOwls) / totalEmployees) * 100)
    },
    average_consistency: Math.round(
      employees.reduce((sum, e) => sum + e.activity_consistency, 0) / totalEmployees
    )
  };
};

module.exports = {
  getEmployeeWorkHours,
  getEmployeeBreakTime,
  getEmployeeAttendance,
  getEmployeeActivityPatterns,
  findArrivalSession, // Add for testing
  findContinuousDeskOccupancy // Add for testing
};
